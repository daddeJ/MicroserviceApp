# Shared Validation Library

## Overview
This document outlines common validation logic that should be extracted into a shared library to ensure consistency across all microservices (UserService, AuthService, LoggerService, AdminService).

---

## 1. Input Validation

### 1.1 String Validators

#### ValidateRequired
```
-> Check if string is null or empty
-> Trim whitespace
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "{fieldName} is required"
```

#### ValidateEmail
```
-> Check if email is null or empty
-> Validate email format using Regex
    -> Pattern: ^[^@\s]+@[^@\s]+\.[^@\s]+$
-> Check email length (max: 254 characters)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid email format"
```

#### ValidateUsername
```
-> Check if username is null or empty
-> Validate length (min: 3, max: 50)
-> Validate characters (alphanumeric, underscore, dash only)
    -> Pattern: ^[a-zA-Z0-9_-]+$
-> Check if starts with letter
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Username must be 3-50 characters, alphanumeric"
```

#### ValidatePassword
```
-> Check if password is null or empty
-> Validate minimum length (min: 8, recommended: 12)
-> Check complexity requirements:
    -> At least 1 uppercase letter
    -> At least 1 lowercase letter
    -> At least 1 digit
    -> At least 1 special character
-> Check against common passwords list (optional)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Password must meet complexity requirements"
```

### 1.2 Identifier Validators

#### ValidateUserId
```
-> Check if userId is null or empty
-> Validate GUID format
    -> Try parse to Guid
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid user ID format"
```

#### ValidateToken
```
-> Check if token is null or empty
-> Validate token format (JWT structure)
    -> Check for 3 parts separated by dots
    -> Validate Base64Url encoding
-> Check token length (reasonable bounds: 100-2000 chars)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid token format"
```

---

## 2. Pagination Validation

### ValidatePaginationParameters
```
-> Validate Page Number:
    -> Check if page >= 1
    -> If invalid, set default: page = 1
-> Validate Page Size:
    -> Check if size >= 1
    -> Check if size <= maxPageSize (100)
    -> If size > maxPageSize, set size = maxPageSize
    -> If invalid, set default: size = 10
-> Return PaginationParams
    - Page (validated)
    - Size (validated)
    - Skip = (Page - 1) * Size
    - Take = Size
```

---

## 3. Role and Tier Validation

### ValidateRole
```
-> Check if role is null or empty
-> Load allowed roles from configuration/constants
    -> AllowedRoles = ["Admin", "SuperAdmin", "User", "Moderator"]
-> Check if role exists in AllowedRoles (case-insensitive)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid role. Allowed roles: {allowedRoles}"
```

### ValidateTier
```
-> Check if tier is provided
-> Validate tier range (1-5)
-> Check if tier is integer
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Tier must be between 1 and 5"
```

### ValidateMultipleRoles
```
-> Check if roles list is null or empty
-> If empty, return valid (optional filter)
-> For each role in list:
    -> ValidateRole(role)
    -> If any invalid, collect errors
-> If any invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid roles: {invalidRoles}"
```

### ValidateMultipleTiers
```
-> Check if tiers list is null or empty
-> If empty, return valid (optional filter)
-> For each tier in list:
    -> ValidateTier(tier)
    -> If any invalid, collect errors
-> If any invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid tiers: {invalidTiers}"
```

---

## 4. Date and Time Validation

### ValidateDateRange
```
-> Check if startDate and endDate are provided
-> Validate startDate <= endDate
-> Check if date range is reasonable (max: 1 year)
-> Check if dates are not in future (for logs/history)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid date range"
```

### ValidateTimestamp
```
-> Check if timestamp is provided
-> Validate timestamp is not default DateTime
-> Check if timestamp is within reasonable range
    -> Not older than system creation date
    -> Not in future
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid timestamp"
```

---

## 5. Session Validation

### ValidateSessionData
```
-> Validate UserId (using ValidateUserId)
-> Validate AccessToken (using ValidateToken)
-> Validate RefreshToken if provided (using ValidateToken)
-> Validate IssuedAt timestamp
-> Validate ExpiresAt timestamp
    -> Check ExpiresAt > IssuedAt
    -> Check ExpiresAt is in future
-> Validate Status
    -> Allowed: ["Active", "Revoked", "Expired"]
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessages = [list of errors]
```

---

## 6. Request Body Validation

### ValidateRegistrationDto
```
-> ValidateUsername(dto.Username)
-> ValidateEmail(dto.Email)
-> ValidatePassword(dto.Password)
-> ValidateRole(dto.Role) if provided
-> ValidateTier(dto.Tier) if provided
-> If any validation fails:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessages = [collected errors]
```

### ValidateLoginDto
```
-> ValidateRequired(dto.Username or dto.Email)
-> ValidatePassword(dto.Password)
-> If email provided, ValidateEmail(dto.Email)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessages = [collected errors]
```

### ValidateUpdateUserDto
```
-> If Email provided: ValidateEmail(dto.Email)
-> If Username provided: ValidateUsername(dto.Username)
-> If Role provided: ValidateRole(dto.Role)
-> If Tier provided: ValidateTier(dto.Tier)
-> Check at least one field is provided for update
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessages = [collected errors]
```

---

## 7. Search and Filter Validation

### ValidateSearchCriteria
```
-> Validate date range if provided (ValidateDateRange)
-> Validate arrays are not empty if provided:
    -> services array
    -> users array
    -> eventTypes array
    -> logLevels array
-> Validate searchText length (max: 500 characters)
-> Validate pagination (ValidatePaginationParameters)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessages = [collected errors]
```

### ValidateLogLevel
```
-> Check if logLevel is provided
-> Validate against allowed log levels
    -> AllowedLevels = ["Trace", "Debug", "Information", "Warning", "Error", "Critical"]
-> Case-insensitive comparison
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid log level. Allowed: {allowedLevels}"
```

### ValidateEventType
```
-> Check if eventType is provided
-> Load allowed event types from configuration
    -> AllowedTypes = ["UserRegistered", "UserLogin", "FailedLogin", "SessionRevoked", "TokenGenerated", "PasswordChanged", etc.]
-> Case-insensitive comparison
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid event type"
```

---

## 8. IP Address and Device Validation

### ValidateIpAddress
```
-> Check if IP is provided
-> Validate IPv4 format
    -> Pattern: ^(\d{1,3}\.){3}\d{1,3}$
    -> Each octet between 0-255
-> Validate IPv6 format (if applicable)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid IP address format"
```

### ValidateDeviceInfo
```
-> Check if deviceInfo is provided
-> Validate length (max: 500 characters)
-> Sanitize input (remove special characters)
-> Check for suspicious patterns (SQL injection, XSS)
-> If invalid:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid device information"
```

---

## 9. Business Logic Validation

### ValidateUserExists
```
-> Accept userId
-> Query user from cache or DB
-> If user not found:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "User not found"
        - ErrorCode = "USER_NOT_FOUND"
```

### ValidateUserNotLocked
```
-> Accept user object
-> Check LockoutEnabled
-> Check LockoutEnd
    -> If LockoutEnd > DateTime.UtcNow
-> If locked:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "User account is locked"
        - ErrorCode = "USER_LOCKED"
```

### ValidateSessionActive
```
-> Accept session object
-> Check Status == "Active"
-> Check ExpiresAt > DateTime.UtcNow
-> If not active:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Session is not active or has expired"
        - ErrorCode = "SESSION_INACTIVE"
```

---

## 10. Security Validation

### ValidateAgainstSqlInjection
```
-> Check input for SQL keywords
    -> Patterns: SELECT, DROP, INSERT, UPDATE, DELETE, UNION, etc.
-> Use parameterized queries (enforcement)
-> If suspicious:
    -> Log security event
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid input detected"
```

### ValidateAgainstXSS
```
-> Check input for script tags
    -> Patterns: <script>, javascript:, onerror=, etc.
-> Encode special characters
-> If suspicious:
    -> Log security event
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Invalid input detected"
```

### ValidateRateLimitCompliance
```
-> Accept userId or IP address
-> Check request count from cache
-> Validate against rate limit threshold
    -> Example: 100 requests per hour
-> If exceeded:
    -> Return ValidationResult
        - IsValid = false
        - ErrorMessage = "Rate limit exceeded"
        - ErrorCode = "RATE_LIMIT_EXCEEDED"
```

---

## 11. Common Response Models

### ValidationResult
```csharp
{
    bool IsValid
    string ErrorMessage
    List<string> ErrorMessages
    string ErrorCode
    Dictionary<string, string[]> FieldErrors
}
```

### PaginationParams
```csharp
{
    int Page
    int Size
    int Skip
    int Take
    int MaxPageSize
}
```

---

## 12. Validation Extensions

### Extension Methods to Consider

#### StringExtensions
```
- IsNullOrWhiteSpace()
- IsValidEmail()
- IsValidUsername()
- IsAlphanumeric()
- SanitizeInput()
- TruncateWithEllipsis(maxLength)
```

#### DateTimeExtensions
```
- IsInPast()
- IsInFuture()
- IsWithinRange(startDate, endDate)
- ToUnixTimestamp()
```

#### CollectionExtensions
```
- IsNullOrEmpty()
- HasDuplicates()
- ContainsAny(items)
```

---

## 13. Configuration Constants

### ValidationConstants
```csharp
{
    // String lengths
    const int USERNAME_MIN_LENGTH = 3
    const int USERNAME_MAX_LENGTH = 50
    const int EMAIL_MAX_LENGTH = 254
    const int PASSWORD_MIN_LENGTH = 8
    const int DEVICE_INFO_MAX_LENGTH = 500
    const int SEARCH_TEXT_MAX_LENGTH = 500
    
    // Pagination
    const int DEFAULT_PAGE = 1
    const int DEFAULT_PAGE_SIZE = 10
    const int MAX_PAGE_SIZE = 100
    const int LOGS_DEFAULT_PAGE_SIZE = 50
    const int LOGS_MAX_PAGE_SIZE = 200
    
    // Tier limits
    const int MIN_TIER = 1
    const int MAX_TIER = 5
    
    // Date ranges
    const int MAX_DATE_RANGE_DAYS = 365
    
    // Rate limiting
    const int RATE_LIMIT_REQUESTS_PER_HOUR = 100
    const int RATE_LIMIT_REQUESTS_PER_MINUTE = 20
    
    // Token
    const int TOKEN_MIN_LENGTH = 100
    const int TOKEN_MAX_LENGTH = 2000
}
```

---

## 14. Usage Examples

### Example 1: Validating Registration DTO
```csharp
var validationResult = ValidationService.ValidateRegistrationDto(registrationDto);
if (!validationResult.IsValid)
{
    return BadRequest(new { errors = validationResult.ErrorMessages });
}
```

### Example 2: Validating Pagination
```csharp
var paginationParams = ValidationService.ValidatePaginationParameters(page, size, maxPageSize: 100);
// Use paginationParams.Skip and paginationParams.Take in query
```

### Example 3: Validating Multiple Fields
```csharp
var validations = new List<ValidationResult>
{
    ValidationService.ValidateUserId(userId),
    ValidationService.ValidateRole(role),
    ValidationService.ValidateTier(tier)
};

var errors = validations.Where(v => !v.IsValid)
                       .SelectMany(v => v.ErrorMessages)
                       .ToList();

if (errors.Any())
{
    return BadRequest(new { errors });
}
```

---

## 15. Best Practices

1. **Early Validation**
    - Validate input as early as possible in the request pipeline
    - Use validation attributes on DTOs where applicable

2. **Consistent Error Messages**
    - Use centralized error message resources
    - Provide clear, actionable error messages

3. **Security First**
    - Always validate and sanitize user input
    - Log validation failures for security monitoring

4. **Performance**
    - Cache validation rules and regex patterns
    - Use compiled regular expressions

5. **Extensibility**
    - Design validators to be easily extended
    - Use composition over inheritance

6. **Testing**
    - Write comprehensive unit tests for all validators
    - Include edge cases and boundary conditions

7. **Documentation**
    - Document validation rules in API documentation
    - Provide examples of valid and invalid inputs