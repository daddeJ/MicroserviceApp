# Microservices Architecture Documentation

---

## UserService

### api/user/register : RegistrationDto
```
-> Validate ModeState
-> Create User in DB
-> Check if Creation Succeeded
-> Check Role Validity
-> Add Role (transactional)
-> Check Tier Validity
-> Add Claim (transactional)
-> _userService: RegistrationUserAsync(userTemp)
    -> Set Cache (user info)
    -> Publish UserRegisteredEvent (userId)
        -> [RabbitMQ] (internal)
            -> AuthService Consumes Event
                -> Received Event
                -> _authService.HandleUserRegistered(userId)
                    -> Get User from Cache
                        -> if null, fetch from DB (fallback)
                    -> Generate JWT Token
                    -> Set Token in Cache
                    -> (Optional) Persist Session Data in DB for Analytics:
                        - UserId
                        - AccessToken
                        - RefreshToken (optional at registration)
                        - IssuedAt / ExpiresAt
                        - LoginIp / DeviceInfo
                        - Status = Active
                    -> Update Analytics Dashboard (optional)
-> Get Token (from cache)
-> Return Ok
    - UserDetail
    - AccessToken
    - RefreshToken (optional)
```

---

### api/user/login : LoginDto
```
-> Validate ModeState / Input
-> Get User from DB
    -> If not found, return error
-> Verify Password
    -> If invalid, return error
-> Check Role & Tier (optional)
-> _userService: LoginUserAsync(user)
    -> Set Cache (user info)
    -> Publish UserLoginEvent (userId)
        -> [RabbitMQ] (internal)
            -> AuthService Consumes Event
                -> Received Event
                -> _authService.HandleUserLogin(userId)
                    -> Get User from Cache
                        -> if null, fetch from DB
                    -> Generate JWT Token
                    -> Generate Refresh Token
                    -> Set Token & Refresh Token in Cache
                    -> Persist Session Data in DB:
                        - UserId
                        - AccessToken
                        - RefreshToken
                        - IssuedAt / ExpiresAt
                        - LoginIp / DeviceInfo
                        - Status = Active
                    -> Update Analytics Dashboard
-> Get Token (from cache)
-> Return Ok
    - UserDetail
    - AccessToken
    - RefreshToken
```

---

## AuthService – Internal Admin API

### GET /admin/sessions
```
-> Receive Request
-> _sessionService.GetAllActiveSessionsAsync()
    -> Query Sessions from DB
        -> WHERE Status = Active
        -> SELECT UserId, AccessToken, RefreshToken, IssuedAt, ExpiresAt, DeviceInfo, IP, Status
    -> Mask Sensitive Data
        -> AccessToken (show last 4 chars)
        -> RefreshToken (show last 4 chars)
    -> Map to SessionDto
-> Return Ok(sessions)
    - List of active sessions
```

### GET /admin/sessions/{userId}
```
-> Receive Request with userId
-> Validate userId
    -> If invalid, return 400 BadRequest
-> _sessionService.GetUserSessionsAsync(userId)
    -> Query Sessions from DB
        -> WHERE UserId = userId
        -> ORDER BY IssuedAt DESC
    -> Mask Sensitive Data
    -> Map to SessionDto
    -> If no sessions found, return empty list
-> Return Ok(sessions)
    - List of user sessions
```

### GET /admin/sessions/stats
```
-> Receive Request
-> _sessionService.GetSessionStatisticsAsync()
    -> Query Active Sessions Count
        -> COUNT WHERE Status = Active
    -> Calculate Login Metrics
        -> Group by Date (day/week/month)
        -> COUNT logins per period
    -> Calculate Token Expiration Stats
        -> COUNT WHERE ExpiresAt < NOW (expired)
        -> COUNT WHERE ExpiresAt > NOW (valid)
        -> AVG token lifetime
    -> Get Device/IP Distribution
        -> GROUP BY DeviceInfo, IP
        -> COUNT per device/IP
    -> Aggregate Results
-> Return Ok(statistics)
    - Active sessions count
    - Login per day/week/month
    - Token expiration stats
    - Device/IP distribution
```

### POST /admin/sessions/revoke
```
-> Receive Request: { userId, token (optional) }
-> Validate Input
    -> userId is required
    -> If invalid, return 400 BadRequest
-> _sessionService.RevokeSessionAsync(userId, token)
    -> If token provided:
        -> Query Session from DB
            -> WHERE UserId = userId AND AccessToken = token
        -> If not found, return 404 NotFound
        -> Update Session:
            -> Status = Revoked
            -> RevokedAt = DateTime.UtcNow
        -> Delete Token from Cache
    -> If token NOT provided:
        -> Query All Sessions for User
            -> WHERE UserId = userId AND Status = Active
        -> Update All Sessions:
            -> Status = Revoked
            -> RevokedAt = DateTime.UtcNow
        -> Delete All Tokens from Cache
    -> Publish SessionRevokedEvent (userId, token)
        -> [RabbitMQ] (internal)
            -> LoggerService Consumes Event
                -> Log revocation action
-> Return Ok
    - Success message
    - Affected session count
```

### POST /admin/sessions/revoke-all
```
-> Receive Request: { userId }
-> Validate userId
    -> If invalid, return 400 BadRequest
-> Check User Exists
    -> Query User from DB
    -> If not found, return 404 NotFound
-> _sessionService.RevokeAllUserSessionsAsync(userId)
    -> Query All Sessions for User
        -> WHERE UserId = userId
    -> Update All Sessions in Transaction:
        -> Status = Revoked
        -> RevokedAt = DateTime.UtcNow
    -> Delete All User Tokens from Cache
        -> Remove AccessToken
        -> Remove RefreshToken
    -> Publish SessionsRevokedEvent (userId)
        -> [RabbitMQ] (internal)
            -> LoggerService Consumes Event
                -> Log bulk revocation action
-> Return Ok
    - Success message
    - Total revoked sessions count
```

---

## LoggerService – Internal Logging API

### GET /logs
```
-> Receive Request with Query Parameters
    -> date (optional)
    -> service (optional)
    -> user (optional)
    -> eventType (optional)
    -> page (default: 1)
    -> size (default: 50, max: 200)
-> Validate Parameters
    -> Validate date format
    -> Validate page and size
-> _logService.GetLogsAsync(filters)
    -> Build Query with Filters
        -> WHERE date BETWEEN start AND end (if provided)
        -> AND Service = service (if provided)
        -> AND UserId = user (if provided)
        -> AND EventType = eventType (if provided)
    -> Apply Pagination
        -> SKIP (page - 1) * size
        -> TAKE size
    -> ORDER BY Timestamp DESC
    -> Map to LogDto
-> Return Ok(logs)
    - Paged log list
    - Total count
    - Current page
    - Total pages
```

### GET /logs/{userId}
```
-> Receive Request with userId
-> Validate userId
    -> If invalid, return 400 BadRequest
-> _logService.GetUserLogsAsync(userId)
    -> Query Logs from DB
        -> WHERE UserId = userId
        -> ORDER BY Timestamp DESC
    -> Map to LogDto
        -> Include:
            - LogId
            - UserId
            - EventType
            - Service
            - Message
            - Timestamp
            - IpAddress
            - DeviceInfo
    -> If no logs found, return empty list
-> Return Ok(logs)
    - List of user logs
```

### GET /logs/stats
```
-> Receive Request
-> _logService.GetLogStatisticsAsync()
    -> Calculate Events Per Period
        -> Query Events grouped by Date
        -> COUNT per day/week/month
        -> GROUP BY EventType
    -> Calculate Failed Login Attempts
        -> Query Logs
            -> WHERE EventType = 'FailedLogin'
            -> GROUP BY Date
            -> COUNT per period
    -> Calculate Token Generation Stats
        -> Query Logs
            -> WHERE EventType = 'TokenGenerated'
            -> GROUP BY Service
            -> COUNT per service
    -> Calculate Errors Per Service
        -> Query Logs
            -> WHERE LogLevel = 'Error' OR EventType LIKE '%Error%'
            -> GROUP BY Service
            -> COUNT per service
    -> Aggregate Results
-> Return Ok(statistics)
    - Events per day/week/month
    - Failed login attempts
    - Token generation per service
    - Errors per service
```

### POST /logs/search
```
-> Receive Request: SearchLogDto
    -> startDate (optional)
    -> endDate (optional)
    -> services (array, optional)
    -> users (array, optional)
    -> eventTypes (array, optional)
    -> logLevels (array, optional)
    -> searchText (optional)
    -> page (default: 1)
    -> size (default: 50, max: 200)
-> Validate Input
    -> Validate date range
    -> Validate arrays are not empty if provided
    -> Validate page and size
-> _logService.SearchLogsAsync(searchCriteria)
    -> Build Complex Query
        -> WHERE Timestamp BETWEEN startDate AND endDate (if provided)
        -> AND Service IN services (if provided)
        -> AND UserId IN users (if provided)
        -> AND EventType IN eventTypes (if provided)
        -> AND LogLevel IN logLevels (if provided)
        -> AND (Message LIKE searchText OR Exception LIKE searchText) (if provided)
    -> Apply Sorting
        -> ORDER BY Timestamp DESC
    -> Apply Pagination
        -> SKIP (page - 1) * size
        -> TAKE size
    -> Execute Query
    -> Map to LogDto
-> Return Ok(results)
    - Matched logs
    - Total count
    - Applied filters
    - Current page
    - Total pages
```

### Internal Event Consumers

#### UserRegisteredEvent Consumer
```
-> Consume UserRegisteredEvent from RabbitMQ
    -> Extract: userId, timestamp, ipAddress, deviceInfo
-> _logService.LogEventAsync()
    -> Create Log Entry:
        - UserId = userId
        - EventType = 'UserRegistered'
        - Service = 'UserService'
        - Message = 'User registered successfully'
        - Timestamp = timestamp
        - IpAddress = ipAddress
        - DeviceInfo = deviceInfo
        - LogLevel = 'Information'
    -> Insert into Logs DB
-> Acknowledge Message
```

#### UserLoginEvent Consumer
```
-> Consume UserLoginEvent from RabbitMQ
    -> Extract: userId, timestamp, ipAddress, deviceInfo, success
-> _logService.LogEventAsync()
    -> Create Log Entry:
        - UserId = userId
        - EventType = success ? 'UserLogin' : 'FailedLogin'
        - Service = 'UserService'
        - Message = success ? 'User logged in successfully' : 'Login attempt failed'
        - Timestamp = timestamp
        - IpAddress = ipAddress
        - DeviceInfo = deviceInfo
        - LogLevel = success ? 'Information' : 'Warning'
    -> Insert into Logs DB
-> Acknowledge Message
```

#### SessionRevokedEvent Consumer
```
-> Consume SessionRevokedEvent from RabbitMQ
    -> Extract: userId, token, revokedBy, timestamp
-> _logService.LogEventAsync()
    -> Create Log Entry:
        - UserId = userId
        - EventType = 'SessionRevoked'
        - Service = 'AuthService'
        - Message = 'Session revoked by admin'
        - Timestamp = timestamp
        - AdditionalData = { revokedBy, token (masked) }
        - LogLevel = 'Warning'
    -> Insert into Logs DB
-> Acknowledge Message
```

---

## AdminController  [Authorize(Policy = "SuperAdminOnly")]

**Route:** api/admin

### 1. GET /users
```
-> Read Query Parameters: role, tier, page, size
-> Validate page and size (default: 1, 10; max pageSize: 100)
-> Validate tier (allowed: 1-5)
    -> If invalid, return 400 BadRequest
-> Validate role (allowed: DataSeeder.AdminRoleAccess)
    -> If invalid, return 400 BadRequest
-> Query Users:
    -> _userManager.Users.AsQueryable()
    -> _userQueryService.GetUsersAsync(queryableUsers, roleList, tierList, pageNumber, pageSize)
-> Return Ok(result)
    - Paged user list with role and tier info
```

### 2. GET /users/{id}
```
-> Get User by Id:
    -> _userManager.FindByIdAsync(id)
    -> If null, return 404 NotFound
-> Get Roles: _userManager.GetRolesAsync(user)
-> Get Claims: _userManager.GetClaimsAsync(user)
-> Return Ok(UserDto)
    - Id, UserName, Email, Role(s), Tier(s)
```

### 3. PATCH /users/{id}
```
-> Read UpdateUserDto from Body
-> Update User:
    -> _userQueryService.UpdateUserAsync(id, model)
    -> Returns (success, error)
-> If success: return 200 Ok with message
-> If failure: return 400 BadRequest with message
```

### 4. DELETE /users/{id}
```
-> Get User by Id: _userManager.FindByIdAsync(id)
    -> If null, return 404 NotFound
-> Soft Delete User:
    -> user.LockoutEnabled = true
    -> user.LockoutEnd = DateTimeOffset.MaxValue
    -> _userManager.UpdateAsync(user)
-> Return 200 Ok with message
```